Title: العوامل وتعابيرها 4
Date: 2021-05-27 12:09
Category: سلسلة مبادئ البايثون
Tags: بايثون 101
Summary: العمليات على مستوى البت
Author: Essa Alshammari
Slug: operators-and-expressions-4

# العمليات على مستوى البت bitwise


كما في المواضيع السابقة هي عدة عوامل نستخدمها لغرض معين, لكن هنا الفرق في انه ستكون المعاملات التي تحيط العامل كسلسلة من الارقام الثنائية وسيكون التعامل معها بت ببت.

ربما في هذا الموضوع نحتاج الى ان نراجع بعض الاشياء 

البت بأختصار هو رقم ثنائي اما 0 او 1, وهو اصغر وحدة بيانات في الحوسبة.

ماهي الارقام الثنائية ؟

هو نظام عد يكون فيه الاساس 2 ويرمز له عادةً بـ 0 او 1 او صح او خطأ.

حتى نفهم ما العد الثنائي يجب ان نقربة للفهم بأستخدام نظام العد العشري التي نستخدمها نحن كبشر.

وهي الارقام التي يكون فيه الاساس 10 والرموز هي الارقام من 0 الى 9.

لنأخذ هذا الرقم كمثال وكيف تم تمثيلة بشكلة التالي:

38

هذا الرقم في نظام العد العشري رُمز له بأستخدام المعادلة التالية

~~~python
>>> 8 * 10 ** 0 + 3 * 10 ** 1
38
~~~

اولا قمنا بأخذ الارقام من الجهة المعاكسة اي من اصغر منزلة للرقم ,ثم نقوم بضربة برقم 10 لانها الاساس ومن ثم نرفعها لاس المنزلة اي عدد الاصفار في المنزلة, وبعد ذلك نقوم بجمعة مع الرقم التالي مع تكرار الخطوات السابقة.

> للتذكير: المنازل هي الاحاد, العشرات, المئات, الالاف..... الخ.

وبذلك عرض لنا نفس الرقم

الان لنقوم بذلك في الارقام الثنائية حتى يتسنى فهمها

لنأخذ الرقم 100110 على سبيل المثال.

نفعل مثل ما فعلنا به مع الرقم السابق بأختلاف الاساس ونحولة الى 2

~~~python
>>> 0 * 2 ** 0 + 1 * 2 ** 1 + 1 * 2 ** 2 + 0 * 2 ** 3 + 0 * 2 ** 4 + 1 * 2 ** 5
38
~~~

لماذا اذن ثنائية بدلا من الاعداد ذات الاساس العشري الذي نعرفة جيدا ؟

فقط لانها اسهل للتعامل في الحوسبة من حيث البوابات المنطقية والدوائر الكهربائية وما الى ذلك من المستويات الدنياً

لذلك تجد موضوع التعامل مع العمليات على مستوى البت قليلة الاستخدام لاننا لا نحتاج لها فكل الحواسب الان تقدم لنا طبقات مجردة مبنية عليها.

ربما تحتاجها في يوم من الايام ! في كتابتها او حتى قراءة شيفرة برنامج اخر !

لذلك كتبنا هذا الموضوع.

> ستجد ان بعض العمليات التي سنشرحها تاليا لا تمس للمنطق بصلة, ذلك لان عقولنا لم تتعود على مثل هذة العمليات.

هناك في البايثون 6 عاملات للعمليات على مستوى البت.

 - `&`
 - `|`
 - `~` 
 - `^`
 - `<<`
 - `>>`


### العامل & and

يقوم هذ العامل عندما يكون بين معاملين بأدراج 1 في الناتج المرجع اذا كان في نفس المكان من المعاملين رقم 1.

مثال:

> لو تذكرون في المواضيع السابقة قلنا انه في البايثون الرقم الثنائي يجب ان يكون مسبوقا بـ `0b`

 
~~~python
>>> x = 0b100110
>>> y = 0b011011
>>> x & y
2
~~~

:) كيف اصبح اثنان! ولماذا؟

- الـ `x` قيمته بالاعداد التي نعرفها هي 38
- الـ `y` قيمته 27
- والناتج 2

ما الذي حدث

الناتج في الواقع هو 

`0b000010`

لنبسطها بالجدول التالي حتى لا نضطر لاعادة الكتابة مع المعاملات الاخرى

|       	|  	|  	|  	|  	|  	| 	|
|--------	|---	|---	|---	|---	|---	|---	|
| قيمة x      	| 0 	| 1 	| 1 	| 0 	| 0 	| 1 	|
| قيمة y      	| 1 	| 1 	| 0 	| 1 	| 1 	| 0 	|
| النتيجة 	| 0 	| 1 	| 0 	| 0 	| 0 	| 0 	|


العامل & يقوم باعطاء 1 في النتيجة اذا كان في كلا المعاملين 1

### العامل | or

يقوم بأرجاع 1 اذا كان في نفس المكان 1 في اي الطرفين و0 اذا كان كلا المعاملين يحملان صفر في نفس المكان

مثال:

~~~python
>>> x = 0b100110
>>> y = 0b011011
>>> bin(x | y)
'0b111111'
~~~

>هنا استخدمنا الفنكشن `bin` حتى نخبر البايثون بأن يرجع الرقم كثنائي.

### العامل ~ not

اولا هذا العامل احادي لا يحتاج لمعاملين هكذا:

```python
~x
```

ثانيا بالاصل هذا العامل يقوم بقلب 1 الى 0 والعكس صحيح لكن لان البايثون تتعامل بطريقة معينة مع الارقام فهو يختلف.

في البايثون يقوم هذا العامل بقلب اشارة الرقم ويقوم بأضافة واحد اليه.

مثال:

```python
>>> x = 0b100110
>>> ~x
-39
>>> bin(~x)
'-0b100111'
```

### العامل ^ xor

يقوم هذا العامل بأرجاع 1 اذا كان اي من الطرفين يحمل واحد في نفس المكان لكن ليس كلاهما 

مثال:

```python
>>> x = 0b100110
>>> y = 0b011011
>>> x ^ y
61
>>> bin(x ^ y)
'0b111101'
```

### العاملان >> و << shift

هذا العاملان احاديات

يقوم بتحويل البت الى اليمين عند استخدام العامل << بمقدار معين والاخر يقوم بذلك على اليسار.

بشكل اوضح من اليمين يعني ان يأخذ البت الاخير ويحذفه

ومن اليسار يعني اضافة 0 الى نهاية الرقم


مثال:

```python
>>> x = 0b100110
>>> x >> 1
19
>>> bin(x >> 1)
'0b10011'
```

> رقم 1 الذي بعد << هو المقدار

مثال على العامل الاخر:

```python
>>> x = 0b100110
>>> x << 1
76
>>> bin(x << 1)
'0b1001100'
```



ختاماً غالبا عندما نتعامل مع لغات عالية المستوى مثل البايثون لن نحتاج لهذة العاملات لكن وجودها وفهمها يعطينا افاقاً اوسع.

